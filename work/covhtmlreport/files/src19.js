var g_data = {"name":"../rtl/i2c_slave_model.v","src":"/////////////////////////////////////////////////////////////////////\n////                                                             ////\n////  WISHBONE rev.B2 compliant synthesizable I2C Slave model    ////\n////                                                             ////\n////                                                             ////\n////  Authors: Richard Herveille (richard@asics.ws) www.asics.ws ////\n////           John Sheahan (jrsheahan@optushome.com.au)         ////\n////                                                             ////\n////  Downloaded from: http://www.opencores.org/projects/i2c/    ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n////                                                             ////\n//// Copyright (C) 2001,2002 Richard Herveille                   ////\n////                         richard@asics.ws                    ////\n////                                                             ////\n//// This source file may be used and distributed without        ////\n//// restriction provided that this copyright statement is not   ////\n//// removed from the file and that any derivative work contains ////\n//// the original copyright notice and the associated disclaimer.////\n////                                                             ////\n////     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     ////\n//// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   ////\n//// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   ////\n//// FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      ////\n//// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         ////\n//// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    ////\n//// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   ////\n//// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        ////\n//// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  ////\n//// LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  ////\n//// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  ////\n//// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ////\n//// POSSIBILITY OF SUCH DAMAGE.                                 ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n\n//  CVS Log\n//\n//  $Id: i2c_slave_model.v,v 1.7 2006-09-04 09:08:51 rherveille Exp $\n//\n//  $Date: 2006-09-04 09:08:51 $\n//  $Revision: 1.7 $\n//  $Author: rherveille $\n//  $Locker:  $\n//  $State: Exp $\n//\n// Change History:\n//               $Log: not supported by cvs2svn $\n//               Revision 1.6  2005/02/28 11:33:48  rherveille\n//               Fixed Tsu:sta timing check.\n//               Added Thd:sta timing check.\n//\n//               Revision 1.5  2003/12/05 11:05:19  rherveille\n//               Fixed slave address MSB='1' bug\n//\n//               Revision 1.4  2003/09/11 08:25:37  rherveille\n//               Fixed a bug in the timing section. Changed 'tst_scl' into 'tst_sto'.\n//\n//               Revision 1.3  2002/10/30 18:11:06  rherveille\n//               Added timing tests to i2c_model.\n//               Updated testbench.\n//\n//               Revision 1.2  2002/03/17 10:26:38  rherveille\n//               Fixed some race conditions in the i2c-slave model.\n//               Added debug information.\n//               Added headers.\n//\n`timescale 1ns/1ns\nmodule i2c_slave_model (scl, sda, start, stop, data_slave_read, data_slave_read_valid);\n\n	//\n	// parameters\n	//\n	parameter I2C_ADR = 7'b001_0000;\n\n	//\n	// input && outpus\n	//\n	input scl;\n	inout sda;\n	output start;\n	output stop;\n	output [7:0] data_slave_read;\n	output data_slave_read_valid;\n	//\n	// Variable declaration\n	//\n	wire debug = 1'b1;\n\n	reg	[7:0] data_slave_read_reg;\n	reg data_slave_read_valid_reg;\n	\n	reg [7:0] mem [15:0]; // initiate memory\n	reg [7:0] mem_adr;   // memory address\n	reg [7:0] mem_do;    // memory data output\n\n	reg sta, d_sta;\n	reg sto, d_sto;\n\n	reg [7:0] sr;        // 8bit shift register\n	reg       rw;        // read/write direction\n\n	wire      my_adr;    // my address called ??\n	wire      i2c_reset; // i2c-statemachine reset\n	reg [2:0] bit_cnt;   // 3bit downcounter\n	wire      acc_done;  // 8bits transfered\n	reg       ld;        // load downcounter\n\n	reg       sda_o;     // sda-drive level\n	wire      sda_dly;   // delayed version of sda\n\n	// statemachine declaration\n	parameter idle        = 3'b000;\n	parameter slave_ack   = 3'b001;\n	parameter get_mem_adr = 3'b010;\n	parameter gma_ack     = 3'b011;\n	parameter data        = 3'b100;\n	parameter data_ack    = 3'b101;\n\n	reg [2:0] state; // synopsys enum_state\n\n	//\n	// module body\n	//\n\n	initial\n	begin\n	   sda_o = 1'b1;\n	   state = idle;\n	end\n\n	// generate shift register\n	always @(posedge scl)\n	  sr <= #1 {sr[6:0],sda};\n\n	//detect my_address\n	assign my_adr = (sr[7:1] == I2C_ADR);\n	// FIXME: This should not be a generic assign, but rather\n	// qualified on address transfer phase and probably reset by stop\n\n	//generate bit-counter\n	always @(posedge scl)\n	  if(ld)\n	    bit_cnt <= #1 3'b111;\n	  else\n	    bit_cnt <= #1 bit_cnt - 3'h1;\n\n	//generate access done signal\n	assign acc_done = !(|bit_cnt);\n\n	// generate delayed version of sda\n	// this model assumes a hold time for sda after the falling edge of scl.\n	// According to the Phillips i2c spec, there s/b a 0 ns hold time for sda\n	// with regards to scl. If the data changes coincident with the clock, the\n	// acknowledge is missed\n	// Fix by Michael Sosnoski\n	assign #1 sda_dly = sda;\n\n\n	//detect start condition\n	always @(negedge sda)\n	  if(scl)\n	    begin\n	        sta   <= #1 1'b1;\n		d_sta <= #1 1'b0;\n		sto   <= #1 1'b0;\n\n	        if(debug)\n	          $display(\"DEBUG i2c_slave; start condition detected at %t\", $time);\n	    end\n	  else\n	    sta <= #1 1'b0;\n\n	always @(posedge scl)\n	  d_sta <= #1 sta;\n\n	// detect stop condition\n	always @(posedge sda)\n	  if(scl)\n	    begin\n	       sta <= #1 1'b0;\n	       sto <= #1 1'b1;\n\n	       if(debug)\n	         $display(\"DEBUG i2c_slave; stop condition detected at %t\", $time);\n	    end\n	  else\n	    sto <= #1 1'b0;\n\n	//generate i2c_reset signal\n	assign i2c_reset = sta || sto;\n\n	// generate statemachine\n	always @(negedge scl or posedge sto)\n	  if (sto || (sta && !d_sta) )\n	    begin\n	        state <= #1 idle; // reset statemachine\n\n	        sda_o <= #1 1'b1;\n	        ld    <= #1 1'b1;\n			data_slave_read_valid_reg <= 0;\n			data_slave_read_reg <= 0;\n	    end\n	  else\n	    begin\n	        // initial settings\n            mem[15] <= 8'hff;\n	        sda_o <= #1 1'b1;\n	        ld    <= #1 1'b0;\n\n	        case(state) // synopsys full_case parallel_case\n	            idle: // idle state\n	              if (acc_done && my_adr)\n	                begin\n	                    state <= #1 slave_ack;\n	                    rw <= #1 sr[0];\n	                    sda_o <= #1 1'b0; // generate i2c_ack\n\n	                    #2;\n	                    if(debug && rw)\n	                      $display(\"DEBUG i2c_slave; command byte received (read) at %t\", $time);\n	                    if(debug && !rw)\n	                      $display(\"DEBUG i2c_slave; command byte received (write) at %t\", $time);\n\n	                    if(rw)\n	                      begin\n							  mem_adr <= 0;\n	                          mem_do <= #1 mem[0];\n\n	                          if(debug)\n	                            begin\n	                                #2 $display(\"DEBUG i2c_slave; data block read %x from address %x (1)\", mem_do, 8'h00);\n	                                #2 $display(\"DEBUG i2c_slave; memcheck [0]=%x, [1]=%x, [2]=%x\", mem[4'h0], mem[4'h1], mem[4'h2]);\n	                            end\n	                      end\n	                end\n\n	            slave_ack:\n	              begin\n	                  if(rw)\n	                    begin\n	                        state <= #1 data;\n	                        sda_o <= #1 mem_do[7];\n	                    end\n	                  else\n	                    state <= #1 get_mem_adr;\n\n	                  ld    <= #1 1'b1;\n	              end\n\n	            get_mem_adr: // wait for memory address\n	              if(acc_done)\n	                begin\n	                    state <= #1 gma_ack;\n	                    mem_adr <= #1 sr; // store memory address\n	                    sda_o <= #1 !(sr < 15); // generate i2c_ack, for valid address\n\n	                    if(debug)\n	                      #1 $display(\"DEBUG i2c_slave; address received. adr=%x, ack=%b\", sr, sda_o);\n	                end\n\n	            gma_ack:\n	              begin\n	                  state <= #1 data;\n	                  ld    <= #1 1'b1;\n	              end\n\n	            data: // receive or drive data\n	              begin\n	                  if(rw)\n	                    sda_o <= #1 mem_do[7];\n\n	                  if(acc_done)\n	                    begin\n	                        state <= #1 data_ack;\n	                        mem_adr <= #2 mem_adr < 15 ? mem_adr + 8'h1 : 0;\n	                        \n							sda_o <= #1 (rw && mem_adr < 15); // send ack on write, receive ack on read\n\n	                        if(rw)\n	                          begin\n	                              #3 mem_do <= mem[mem_adr];\n	                              if(debug)\n	                                #5 $display(\"DEBUG i2c_slave; data block read %x from address %x (2)\", mem_do, mem_adr);\n	                          end\n\n	                        if(!rw)\n	                          begin\n								data_slave_read_reg <= sr;\n								data_slave_read_valid_reg <= 1;\n                                mem[ mem_adr[3:0] ] <= #1 sr; // store data in memory\n                                sda_o <= #1 !(mem_adr < 15);\n                                if(debug)\n                                #2 $display(\"DEBUG i2c_slave; data block write %x to address %x\", sr, mem_adr);\n	                          end\n	                    end\n	              end\n\n	            data_ack:\n	              begin\n					  if (data_slave_read_valid_reg)\n					  	data_slave_read_valid_reg <= 0;\n	                  ld <= #1 1'b1;\n	                  if(rw)\n	                    if(sr[0]) // read operation && master send NACK\n	                      begin\n	                          state <= #1 idle;\n	                          sda_o <= #1 1'b1;\n	                      end\n	                    else\n	                      begin\n	                          state <= #1 data;\n	                          sda_o <= #1 1'b1;\n	                      end\n	                  else\n	                    begin\n	                        state <= #1 data;\n	                        sda_o <= #1 1'b1;\n	                    end\n	              end\n\n	        endcase\n	    end\n\n	// read data from memory\n	always @(posedge scl)\n	  if(!acc_done && rw)\n	    mem_do <= #1 {mem_do[6:0], 1'b1}; // insert 1'b1 for host ack generation\n\n	// generate tri-states\n	assign sda = sda_o ? 1'bz : 1'b0;\n	assign stop = sto;\n	assign start = sta;\n	assign data_slave_read = data_slave_read_reg;\n	assign data_slave_read_valid = data_slave_read_valid_reg;\n/*\n	//\n	// Timing checks\n	//\n\n	wire tst_sto = sto;\n	wire tst_sta = sta;\n\n	specify\n	  specparam normal_scl_low  = 4700,\n	            normal_scl_high = 4000,\n	            normal_tsu_sta  = 4700,\n	            normal_thd_sta  = 4000,\n	            normal_tsu_sto  = 4000,\n	            normal_tbuf     = 4700,\n\n	            fast_scl_low  = 1300,\n	            fast_scl_high =  600,\n	            fast_tsu_sta  = 1300,\n	            fast_thd_sta  =  600,\n	            fast_tsu_sto  =  600,\n	            fast_tbuf     = 1300;\n\n	  $width(negedge scl, normal_scl_low);  // scl low time\n	  $width(posedge scl, normal_scl_high); // scl high time\n\n	  $setup(posedge scl, negedge sda &&& scl, normal_tsu_sta); // setup start\n	  $setup(negedge sda &&& scl, negedge scl, normal_thd_sta); // hold start\n	  $setup(posedge scl, posedge sda &&& scl, normal_tsu_sto); // setup stop\n\n	  $setup(posedge tst_sta, posedge tst_sto, normal_tbuf); // stop to start time\n	endspecify\n*/\nendmodule\n\n\n","lang":"verilog"};
processSrcData(g_data);