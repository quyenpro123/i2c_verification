var g_data = {"name":"../rtl/i2c_master_fsm.v","src":"module i2c_master_fsm (\n    input           enable_i            ,   // enable signal from MCU\n    input           reset_ni            ,   // reset negative signal from MCU\n    input           repeat_start_i      ,   // repeat start signal from MCU\n    input           rw_i                ,   // bit 1 is read - 0 is write\n    input           full_i              ,   // FIFO buffer is full\n    input           empty_i             ,   // FIFO buffer is empty\n    input           i2c_core_clk_i      ,   // i2c core clock\n    input           i2c_sda_i           ,   // i2c sda feedback to FSM\n    input           i2c_scl_i           ,   // i2c scl feedback to FSM\n\n    output          w_fifo_en_o         ,   //  enable write data into fifo memory\n    output          r_fifo_en_o         ,   //  enable read data from fifo memory\n\n    output	    reg             sda_low_en_o        ,   // when = 1 enable sda down 0\n    output	    reg             clk_en_o            ,   // enbale to generator clk\n    output	    reg             write_data_en_o     ,   // enable write data on sda\n    output	    reg             write_addr_en_o     ,   // enable write address of slave on sda\n    output	    reg             receive_data_en_o   ,   // enable receive data from sda\n    output              [3:0]   count_bit_o         ,   // count bit data from 7 down to 0\n    output	    reg             i2c_sda_en_o        ,   // allow impact to sda\n    output	    reg             i2c_scl_en_o        ,   // allow impact to scl \n    output                      start_done_o        ,   // state-start done\n    output                      reset_done_o            \n);\n\n    // State\n    parameter   IDLE            =   4'b0000   ;\n    parameter   START           =   4'b0001   ;\n    parameter   ADDRESS         =   4'b0010   ;\n    parameter   READ_ACK        =   4'b0011   ;\n    parameter   WRITE_DATA      =   4'b0100   ;\n    parameter   READ_LATER_ACK  =   4'b0101   ;\n\n    parameter   READ_DATA       =   4'b0110   ;\n    parameter   WRITE_ACK       =   4'b0111   ;\n\n    parameter   REPEAT_START    =   4'b1000   ;\n    parameter   STOP            =   4'b1001   ;\n\n    // Declare current state, next state\n    reg     [3:0]       currrent_state              ;\n    reg     [3:0]       next_sate                   ;\n\n    // Declare count value\n    //reg     [2:0]       count_clk_core              ;\n    reg                 confirm                     ;   // when i2c_scl_i from 1 down to 0, confirm = 1 \n    reg     [3:0]       count_scl_posedge           ;\n    reg     [3:0]       count_scl_posedge_temp      ;\n    reg     [3:0]       count_bit                   ;\n	reg		read_ack_to_read_done	                ;\n	reg		read_ack_to_write_done	                ;\n    reg     scl_later		                        ;\n    wire    scl_positive	                        ;\n	wire	scl_negative	                        ;\n\n\n    // Declare register of ouput\n    reg                 w_fifo_en                               ;\n    reg                 r_fifo_en                               ;\n    reg                 start_done                              ;\n    reg                 reset_done                              ;\n\n    assign              count_bit_o         =   count_bit       ;\n    assign              w_fifo_en_o         =   w_fifo_en       ;\n    assign              r_fifo_en_o         =   r_fifo_en       ;\n    assign              start_done_o        =   start_done      ;\n    assign              reset_done_o        =   reset_done      ;\n\n    // Current State register logic\n    always @ (posedge i2c_core_clk_i,   negedge reset_ni) begin\n        if (~reset_ni) begin\n\n            currrent_state      <=  IDLE        ;\n            reset_done          <=  1           ;\n\n        end\n\n        else begin\n\n            currrent_state  	<=  next_sate   ;\n            reset_done          <=  0           ;\n\n        end\n\n    end\n\n    // Next state comnibational logic\n    always @ (*)    begin\n\n        case (currrent_state)\n\n            IDLE    :   begin\n                \n                if (enable_i ) begin\n                    next_sate   =   START      ;\n                end\n                else begin\n                    next_sate   =   IDLE       ;\n                end\n\n            end\n\n\n            START   :   begin\n\n				if (i2c_scl_i == 0) begin                           //  Wait for scl low, and then to next sate\n\n                	next_sate           =   ADDRESS             ;\n\n                end\n\n                else begin\n\n                    next_sate           =   START               ;\n\n                end\n\n            end\n\n\n            ADDRESS :   begin\n\n                //When the 8 bits data have been transmitted, \n                //wait for the scl line is low and then move to the next state\n                if (count_scl_posedge == 8 && scl_negative == 1) begin\n                    next_sate   =   READ_ACK    ;\n                end\n                else begin\n                    next_sate   =   ADDRESS     ;\n                end \n\n            end\n\n            READ_ACK    :   begin\n\n				// When have an ACK or NACK, wait for scl is negedge and then to next state\n                if ((scl_negative == 1) && (read_ack_to_read_done == 0 && read_ack_to_write_done == 0)) begin\n\n                    next_sate   =   STOP    ;\n\n                end\n\n				else if ((scl_negative == 1) && (read_ack_to_read_done == 1)) begin\n\n					next_sate       		=   READ_DATA	;\n\n				end\n\n				else if ((scl_negative == 1) && (read_ack_to_write_done == 1)) begin\n\n					next_sate       		=    WRITE_DATA   ;\n\n				end				\n\n                else begin\n                    next_sate     =       READ_ACK    ;\n                end\n\n            end\n\n            WRITE_DATA  :   begin\n\n                //When the 8 bits data have been transmitted, \n                //wait for the scl line is high and then move to the next state\n                if (count_scl_posedge == 8 && scl_negative == 1) begin\n\n                    next_sate   =   READ_LATER_ACK              ;\n\n                end \n\n                else begin\n\n                    next_sate   =   WRITE_DATA                  ;\n\n                end\n\n            end\n\n            READ_LATER_ACK  :   begin\n\n                if (repeat_start_i) begin\n\n                    next_sate   =   REPEAT_START                ;\n\n                end\n\n				else if ((scl_negative == 1) && ((empty_i == 1) || (read_ack_to_write_done == 0))) begin\n\n					next_sate	=	STOP	                    ;\n\n				end\n\n				else if ((scl_negative) && (read_ack_to_write_done == 1)) begin		// wait for scl low and then to next state\n\n					next_sate				=	WRITE_DATA		;\n\n				end\n		\n                else begin\n\n                    next_sate           =       READ_LATER_ACK  ;\n\n                end\n\n            end\n\n            READ_DATA   :   begin\n\n                if (count_scl_posedge == 8 && scl_negative == 1) begin\n                    next_sate       =       WRITE_ACK       ;\n                    \n                end \n                else begin\n                    next_sate       =       READ_DATA       ;\n                end\n\n            end\n\n            WRITE_ACK   :   begin\n\n				if (scl_negative) begin\n\n                	if (repeat_start_i) begin\n                    	next_sate       =      REPEAT_START     ; \n                	end \n                	else if (full_i == 0) begin\n                    	next_sate       =       READ_DATA       ;\n                	end\n                	else begin\n                    	next_sate       =       STOP            ;\n                	end\n\n				end\n				else begin\n					next_sate		=		WRITE_ACK		;\n				end\n\n            end\n\n            REPEAT_START    :    begin\n                if (scl_positive) begin\n                    next_sate           =       START         ;\n                end\n                else begin\n                    next_sate           =       REPEAT_START    ;\n                end\n\n            end\n\n            STOP    :   begin\n\n				if (scl_positive) begin\n                	next_sate           	=       IDLE            ;\n				end\n				else begin\n					next_sate				=		STOP			;\n				end\n\n            end\n\n\n            default: next_sate      	=       IDLE            ;\n        endcase\n\n    end\n\n    // Output and internal signal combinational logic\n    always @(*) begin\n        \n        case (currrent_state)\n            \n            IDLE            :   begin\n                //  Output\n                clk_en_o            =       0           ;\n                sda_low_en_o        =       0           ;\n                write_data_en_o     =       0           ;\n                write_addr_en_o     =       0           ;\n                receive_data_en_o   =       0           ;\n                i2c_sda_en_o        =       0           ;\n                i2c_scl_en_o        =       0           ;\n\n                //  Internal signal\n                start_done              =   0           ;\n            end\n\n            //-------------------------------------------------------\n            START           :   begin\n                clk_en_o            =       1           ;\n                sda_low_en_o        =       1           ;\n                write_data_en_o     =       0           ;\n                write_addr_en_o     =       0           ;\n                receive_data_en_o   =       0           ;\n                i2c_sda_en_o        =       1           ;\n                i2c_scl_en_o        =       1           ;\n                \n                //  Internal signal\n                start_done              =   1           ;\n            end\n\n            //-------------------------------------------------------\n            ADDRESS         :   begin\n                clk_en_o            =       1           ;\n                sda_low_en_o        =       0           ;\n                write_data_en_o     =       0           ;\n                receive_data_en_o   =       0           ;\n\n                //when scl is low, we can write address of slave on sda line\n                if (i2c_scl_i == 0)    \n                    write_addr_en_o     =       1       ;\n                else    \n                    write_addr_en_o     =       0       ;\n\n				i2c_sda_en_o    		=       1       ;\n                i2c_scl_en_o        	=       1       ;\n                \n                //  Internal signal\n                start_done              =   1           ;\n            end\n\n            //-------------------------------------------------------\n            READ_ACK        :   begin\n                // Output\n                clk_en_o            =       1           ;\n                sda_low_en_o        =       0           ;\n                write_data_en_o     =       0           ;\n                write_addr_en_o     =       0           ;\n                receive_data_en_o   =       0           ;\n                i2c_sda_en_o        =       0           ;\n                i2c_scl_en_o        =       1           ;\n\n                //Internal signal\n                start_done              =   1           ;\n            end\n\n            //-------------------------------------------------------\n            WRITE_DATA      :   begin\n                clk_en_o            =       1           ;\n                sda_low_en_o        =       0           ;\n                write_addr_en_o     =       0           ;\n                receive_data_en_o   =       0           ;\n\n                //when scl is low, we can write data on sda line\n                if (i2c_scl_i == 0)    \n                    write_data_en_o     =       1           ;\n                else    \n                    write_data_en_o     =       0           ;\n\n				i2c_sda_en_o    		=       1           ;\n                i2c_scl_en_o        	=       1           ;\n                                \n                //  Internal signal\n                start_done              =   1           ;                \n            end\n\n            //-------------------------------------------------------\n            READ_LATER_ACK  :   begin\n                clk_en_o            =       1           ;\n                sda_low_en_o        =       1           ;\n                write_data_en_o     =       0           ;\n                write_addr_en_o     =       0           ;\n                receive_data_en_o   =       0           ;\n                i2c_sda_en_o        =       0           ;\n                i2c_scl_en_o        =       1           ;\n\n                // Internal signal\n                start_done              =   1           ;\n            end\n\n            //-------------------------------------------------------\n            READ_DATA       :   begin\n                clk_en_o            =       1           ;\n                sda_low_en_o        =       0           ;\n                write_data_en_o     =       0           ;\n                write_addr_en_o     =       0           ;\n\n                //when scl is hight, we can receive data from sda\n                if (i2c_scl_i)    \n                    receive_data_en_o   =       1       ;\n                else    \n                    receive_data_en_o   =       0       ;\n\n                i2c_sda_en_o        =       0           ;\n                i2c_scl_en_o        =       1           ;\n                                \n                //  Internal signal\n                start_done              =   1           ;\n            end\n\n            //-------------------------------------------------------\n            WRITE_ACK       :   begin\n                clk_en_o            =       1           ;\n                sda_low_en_o        =       1           ;\n                write_data_en_o     =       0           ;\n                write_addr_en_o     =       0           ;\n                receive_data_en_o   =       0           ;\n                i2c_sda_en_o        =       1           ;\n                i2c_scl_en_o        =       1           ;\n                                \n                //  Internal signal\n                start_done              =   1           ;\n            end\n\n            //-------------------------------------------------------\n            REPEAT_START    :   begin\n                clk_en_o            =       1           ;\n				sda_low_en_o    	=       0           ;\n                write_data_en_o     =       0           ;\n                write_addr_en_o     =       0           ;\n                receive_data_en_o   =       0           ;\n                i2c_sda_en_o        =       0           ; // off i2c_sda_en to pull sda upto 1\n                i2c_scl_en_o        =       1           ;\n                \n                //  Internal signal\n                start_done              =   1           ;\n            end\n\n            //-------------------------------------------------------\n            STOP            :   begin\n                clk_en_o            =       1           ;\n                if (i2c_sda_i == 1) begin                   //  If sda is high, we will set sda to low\n                    sda_low_en_o    =       1           ;\n                end\n                else begin\n                    sda_low_en_o    =       0           ;\n                end\n                \n                write_data_en_o     =       0           ;\n                write_addr_en_o     =       0           ;\n                receive_data_en_o   =       0           ;\n                i2c_sda_en_o        =       1           ;\n                i2c_scl_en_o        =       1           ;\n                                \n                //  Internal signal\n                start_done              =   1           ;\n            end\n\n            //-------------------------------------------------------\n            default         :   begin\n                clk_en_o            =       0           ;\n                sda_low_en_o        =       0           ;\n                write_data_en_o     =       0           ;\n                write_addr_en_o     =       0           ;\n                receive_data_en_o   =       0           ;\n                i2c_sda_en_o        =       0           ;\n                i2c_scl_en_o        =       0           ;\n                                \n                //  Internal signal\n                start_done              =   0           ;\n            end\n        endcase\n\n    end\n\n    //--------------------------------------------------------------------\n    // Detect positive scl\n\n    always @(posedge    i2c_core_clk_i, negedge     reset_ni) begin\n        if (~reset_ni) begin\n            scl_later   <=  1              ;\n        end\n        else begin\n            scl_later   <=  i2c_scl_i       ;\n        end\n    end\n\n    assign  scl_positive = i2c_scl_i & (~scl_later) 	;\n	assign 	scl_negative = (~i2c_scl_i) & (scl_later)	;\n\n    // end detect positive scl\n    //------------------------------------------------------------------------\n    \n    // Handle count_scl_posedge\n    always @(*) begin\n        if (currrent_state  ==  ADDRESS  || currrent_state == READ_DATA  ||  currrent_state  ==  WRITE_DATA) begin\n            //count_scl_posedge   =   scl_positive ? (count_scl_posedge + 1) : count_scl_posedge  ;\n            if (scl_positive) begin\n                count_scl_posedge   =   count_scl_posedge   +   1   ;\n            end\n            else begin\n                count_scl_posedge   =   count_scl_posedge_temp      ;\n            end\n\n        end\n        else begin\n            count_scl_posedge   =   0   ;\n        end\n    end\n\n\n    // Handle read/write-enbale signal to FIFO and count posedge of clock core\n    always @ (posedge i2c_core_clk_i	, negedge reset_ni) begin\n        if (~reset_ni) begin\n            r_fifo_en               <=  0              	;\n			w_fifo_en	            <=	0				;\n            count_scl_posedge_temp  <=  0               ;\n            count_bit               <=  0               ;\n            read_ack_to_read_done	<=	0               ;\n            read_ack_to_write_done	<=	0               ;\n            \n        end\n        else begin\n            count_scl_posedge_temp  <=  count_scl_posedge   ;\n			// enable read/ write data from/to FIFO when READ_LATER_ACK state and WRITE_ACK state\n			// at frist READ_ACK state , data is always valid, do not enable read.\n            if ((currrent_state == READ_LATER_ACK) && (scl_positive == 1)) begin\n				r_fifo_en   <=  1           ;\n			end\n			else begin\n				r_fifo_en	<=	0	        ;\n			end\n\n			if ((currrent_state == WRITE_ACK) && (scl_positive == 1)) begin\n				w_fifo_en   <=  1           ;\n			end\n			else begin\n				w_fifo_en	<=	0	        ;\n			end\n\n            // Handle count_bit to transfer to datapath\n            if (currrent_state  ==  ADDRESS  || currrent_state  ==  WRITE_DATA) begin\n\n            // Each postitive of scl, if count_bit != 0 , reduce count_bit by 1\n                count_bit     <=   (count_bit_o != 0 && scl_positive) ? (count_bit - 1) : count_bit  ;\n\n            end\n\n            else if (currrent_state == READ_DATA) begin\n\n                // Each negative of scl, if count_bit != 0 , reduce count_bit by 1\n                count_bit     <=   (count_bit_o != 0 && scl_negative) ? (count_bit - 1) : count_bit   ;\n\n            end\n\n            else begin\n                count_bit     <=   7           ;\n            end\n\n            // Handle internal signal : read_ack_to_read/write_done\n            if ((currrent_state == READ_ACK) || (currrent_state == READ_LATER_ACK)) begin\n                if (scl_positive == 1 && i2c_sda_i == 0 && rw_i == 1 && full_i == 0) begin    \n\n                    read_ack_to_read_done	<=	1         ; \n                    read_ack_to_write_done	<=	0         ;\n\n                end\n\n                else if (scl_positive == 1 && i2c_sda_i == 0 && rw_i == 0 && empty_i == 0) begin\n\n                    read_ack_to_read_done	<=	0        ;\n                    read_ack_to_write_done	<=	1        ;\n\n                end\n            end\n            else begin\n                read_ack_to_read_done	<=	0        ;\n                read_ack_to_write_done	<=	0        ;\n            end\n\n        end\n\n    end\n\nendmodule","lang":"verilog"};
processSrcData(g_data);