var g_data = {"name":"../rtl/wptr_full.v","src":"\n// Write pointer and full logic\n// The n-bit pointer ( wptr ) is passed to the read clock domain through the sync_w2r module. \n// The (n-1)-bit pointer ( waddr ) is used to address the FIFO buffer.\n\nmodule wptr_full	#(parameter	ADDRSIZE = 4)\n(\n	input		[ADDRSIZE : 0]		wq2_rptr_i	, // The pointer synchronized from read-domain to write-domain\n	input							winc_i		, // Write increase how many cells\n	input							wclk_i		, // The clock of write-domain\n	input							wrst_ni		, // The negative reset signal of write-domain\n	output							wfull_o		, // Output is the buffer is full, can not write\n	output		[ADDRSIZE : 0]		wptr_o		, // The gray-pointer of write-domain used for synchronization to read-domain\n	output		[ADDRSIZE - 1 : 0]	waddr_o	  	, // The address used write data to FIFO memory\n	output							w_almost_full_o 	// Almost full\n);\n\n	// Decalar reg of output\n	reg							wfull		    	;\n	reg		[ADDRSIZE : 0]		wptr				;\n	reg		[ADDRSIZE - 1 : 0]	waddr  				;\n	reg							w_almost_full		;\n\n	// Decalar pointer\n	reg		[ADDRSIZE : 0]	wbin		; // binary write-pointer\n	wire	[ADDRSIZE : 0]	wbinnext	; // binary write-pointer where the next address is to be write\n	wire	[ADDRSIZE : 0]	wgraynext	; // gray   write-pointer where the next address is to be write\n	wire	[ADDRSIZE : 0]	wgraynextp1	; // gray   write-pointer converted from (wbinnext + 1)\n\n	// Connect reg to output\n	assign		wfull_o		=		wfull			;\n	assign		wptr_o		=		wptr			;\n	assign		waddr_o		=		waddr			;\n	assign		w_almost_full_o	=	w_almost_full	;\n\n	// memory write-address pointer\n	always	@ (*)\n	begin\n\n		waddr	  =		wbin[ADDRSIZE - 1 : 0]		;\n\n	end\n\n	// Caculator write binary next pointer = write binary + increment if FIFO buffer not full\n	assign	wbinnext  =		wbin + (winc_i & ~wfull)	;\n\n	// Convert binary to gray\n	assign	wgraynext =		(wbinnext >> 1) ^ wbinnext	;\n\n	// Almost full if wptr-binary + 1 = synchrosized rptr\n	assign	wgraynextp1	=	((wbinnext + 1) >> 1) ^ (wbinnext + 1)	;\n\n	// gray pointer and binary pointer of write-domain\n	always	@ (posedge wclk_i,	negedge wrst_ni)\n	begin\n		\n		if (~wrst_ni)\n			{wptr, wbin}	<=	0						;\n		else\n			{wptr, wbin}	<=	{wgraynext, wbinnext}	;\n\n	end\n\n	//------------------------------------------------------------------\n 	// FIFO full if 2 MSB bit of write gray next != synchronized rptr and other ==\n 	// assign wfull_val=((wgnext[ADDRSIZE] !=wq2_rptr[ADDRSIZE] )    &&\n 	// 					 (wgnext[ADDRSIZE-1] !=wq2_rptr[ADDRSIZE-1]) &&\n 	// 					 (wgnext[ADDRSIZE-2:0]==wq2_rptr[ADDRSIZE-2:0]));\n 	//------------------------------------------------------------------\n\n	assign	wfull_val			=	(wq2_rptr_i == { ~wgraynext[ADDRSIZE : ADDRSIZE - 1], \n											  		  wgraynext[ADDRSIZE - 2 : 0]		});\n		\n	assign	w_almost_full_val	=	(wq2_rptr_i == { ~wgraynextp1[ADDRSIZE : ADDRSIZE - 1], \n											  		  wgraynextp1[ADDRSIZE - 2 : 0]		});\n\n	// Logic wfull\n	always	@ (posedge wclk_i,	negedge wrst_ni)\n	begin\n	\n		if	(~wrst_ni)\n		begin\n			wfull				<=	1'b0		;\n			w_almost_full		<=	1'b0		;\n		end\n\n		else\n		begin\n			wfull				<=	wfull_val			;\n			w_almost_full		<=	w_almost_full_val	;\n		end\n\n	end\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);